\section{Systemmodel}
	\subsection{System structure}
			\subsubsection{Modules}
				%INSERT SYSTEMMODELCHART HERE
				The main architecture pattern the system is oriented to, is the Model-View-Controller. But 				only the main structure, the architecture should be seen as parallel model.
			\subsubsection{Controller}
				The Controller is basically the whole scheduler-module. It controls the data flow with the 				data structure(Model) and the Data Mining-module which both of them are part of the 						scheduler. Furthermore, the scheduler is responsible for the communication with the code-             				and executer interface and the MPI-world. There will be a scientific code bound to the 						scheduler and executed with different tasks(different parameter input), those will be 						brought in order through the scheduler. This will be organized with special scheduler 						algorithms depend on the data mining and the statistics
			\subsubsection{Model}
				The Model is represented as an high performance file system. Data which will be collected 					for statistics will be stored in such a file in the file system. Also the data for 							bookkeeping with information about the progress of the tasks which are executed on the 						computer cluster will be stored in one file. The queue of the task order will be also 						placed in a file. 
			\subsubsection{View}
				The essential point of visualization will be the graphical output of the collected data. 					Bookkeeping and statistic can be plotted after the calculation.
				A GUI is a nice-to-have feature and is first of all not in planning. The input for the 						controller will be managed trough the MOAB Interface.
\newpage
\subsection{Scenarios}
			
\subsubsection{Expanding universe simulation}

A scientist named John wrote some computer code to simulate the physics of mass in an expanding universe. In order to track trillions of particles in universe, the code should be executed on a supercomputer in an organized and smart manner. 
Firstly, John reserves the required number of nodes using MOAB Workload Manager. After receiving the specific number of nodes, John runs the scheduler and chooses whether he wants to have multiple-queue or single queue scheduling. The scheduler initializes the scientific code and starts to schedule the initial tasks. The scheduler strives to keep as many processes as possible running at the same time and get
their results as soon as possible. To achieve these results, the scheduler uses different strategies at specific times (e.g. Shortest Job First, First In First Out, Longest Job First, etc). After all tasks have been successfully executed, John gets an information that the expanding universe was successfully simulated. 

\subsection{Use cases}

\subsubsection{Scheduling system - Activity diagram}
	\begin{figure}[H]
		\includegraphics[width=1.5\textwidth,scale=0.75,trim=7cm 0 -7cm 0]{images/usecasediagram.png}
		\caption{Use case diagram}
	\end{figure}

\newpage
\subsubsection{Task Stealing (Nice to have) - activity diagram with textual description}
\vspace{1.5cm}
\begin{figure}[H]
	\includegraphics[width=15cm]{images/task_stealing_pap.jpg}
	\caption{Activity diagram of the task stealing algorithm (Source: PSE-Scheduling.pdf)}
\end{figure}
\newpage
\begin{description}
\item [1. Brief Description]\hfill \\
This use case describes the way a task stealing algorithm works inside a dynamic scheduler in order to reduce the amount of process migration between processors.

\item [2. Actors]\hfill \\
No actors. 


\item [3. Preconditions]\hfill \\
\vspace{-6.5mm}
\begin{itemize}
\item The scheduler has been initialized and it has already created a MPI memory window for RMA (Remote Memory Access).
\item Information about initial tasks has been collected from code preprocessing, received tasks from which have been placed to the queue.
\end{itemize}

\item [4. Basic Flow of Event]\hfill \\
The use case begins when the scheduler checks if there are tasks in its own queue.If there is a task in the queue, it will be executed. After the task has been executed, all collected results will get placed in the database in an organized manner.
If there isn't any task in the queue, the task stealing process will be initiated.\newline First of all, the scheduler will cycle through all running processes in other processors and try to steal an idle task from them. In order to check the other processes' queue for an idle task, the scheduler tries to block the RMA window for offsets and statuses, after which it checks whether there are any idle tasks. If the queue is empty or if the RMA window is currently blocked, the scheduler repeats the same procedure for remaining processors. If after checking all processes, no idle task was found, the scheduler changes its own state to idle. If this idle state doesn't change for a specific amount of cycles, which means that no tasks were stolen in this period, the scheduler finally checks to make sure that no process is currently running in any processor and if that's the case, it finishes its own routine. 


\item [5. Post-conditions]\hfill \\
\vspace{-6.5mm}
\begin{enumerate}
\item The scheduler frees the allocated MPI memory window for RMA.
\item The scheduler executes the finishing post processing routine, where it collects information from the whole process (e.g. global total run time).
\end{enumerate}

\item [6. Special requirements]\hfill \\
\vspace{-6.5mm}
\begin{enumerate}
\item The scheduler should have access to the executer interface.
\item The scheduler should be accessible through an interface, in order to receive new tasks from the code interface.
\end{enumerate}

\end{description}

\newpage
\subsection{Object model}

\vspace{0.5cm}
\subsubsection{Scheduler modules and system events}
\vspace{0.5cm}
The main modules of the project are the following:
\begin{description}
\item[Scheduler] Contains a variety of scheduling algorithms and strategies;
\item[Data Mining] Analyses the statistics to define resource requirements for a task
\item[Database] Is used to keep statistics, bookkeeping and local schedule
\item[Communicator (Nice-to-have)] Has to organize a multi-level communication among
multiple parallel schedulers
\end{description}
\vspace{1cm}
The picture below describes the basic object model of a scheduler, its modules and interaction (system events) between them.

\vspace{1cm}
	\begin{figure}[H]
\includegraphics[width=.9\textwidth,height=.9\textheight,keepaspectratio]	{images/modules.jpg}
	\caption{Basic description of modules}
	\end{figure}
\newpage

\subsection{Dynamic models}
\vspace{0.5cm}
\subsubsection{Single-queue master-managed scheduling}
\vspace{0.5cm}
A single-queue master-managed scheduling is a way to schedule many tasks, where each process (instance of the task) can request master to access the queue. The picture below describes the program flow of a scheduler by a single queue, where the queue is managed by only one process (master). 
\vspace{1cm}
	\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{images/Master-slave.jpg}
	\caption{Single queue scheduling with a master-slave diagram} 
	\end{figure}
\newpage
\subsubsection{Multiple-queues scheduling (Nice-to-have)}	
\vspace{0.5cm}
A multiple-queues scheduling is a way to schedule many tasks, where each process has its own queue, and does the same task. The picture below describes the program flow of a scheduler designed by multiple queues, where the queue managing is based on task-stealing algorithm.
\vspace{1cm}
	\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{images/Task-stealing.jpg}
	\caption{Multiple-queues scheduling managed by task-stealing algorithm}
	\end{figure}
\newpage
	
\subsection{Graphical user interface}
	\subsubsection{Command line parameters}
		The dynamic scheduler for scientific simulations is started via the command line. The scheduler takes the following parameters as command line parameters:
	
		\begin{itemize}	
			\item Syntax: [OPTION]... [RUN ARGUMENTS]...
				
			\item OPTIONS:
							
				\subitem -a: choose between multiple-queues scheduling (multi-queue) and single-queue scheduling (single-queue) (e.g. -a multi-queue or -a single-queue). The default strategy is single-queue (nice-to-have)
					
			\item RUN ARGUMENTS:
				\subitem The run arguments will be passed to the scientific code to initialize the code
		\end{itemize}
		
	\subsubsection{Graphical user interface (GUI) (nice-to-have)}
		The Graphical user interface (GUI) is a nice to have feature. The scientist should be able to generate easily a shell script which can run via MOAB Workload Manager on the supercomputer. Following configuration can be edit via the GUI:
		
		\begin{itemize}
			\item Scheduling strategy
			\item Number of nodes
			\item Number of processes per node
			\item Wall-clock time. Default units are seconds. 
			HH:MM:SS format is also accepted.
			\item Maximum amount of physical memory used by any single process of the job. Allowed units are kb, mb, gb. Be aware that processes are either MPI tasks if running MPI parallel jobs or threads if running multithreaded jobs.
			\item Maximum amount of physical memory used by the job.
			Allowed units are kb, mb, gb. Be aware that this memory value is the accumulated memory for all MPI tasks or all threads of the job.
			\item Run Arguments for the scientific code
			\item User specified name for the job.
			\item Defines the queue class
			\item Expand the list of environment variables that are exported to the job
			\item Send email to the specified email address when job begins, ends or aborts
		\end{itemize}
	
	